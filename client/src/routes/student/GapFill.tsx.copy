import { useEffect, useMemo, useRef, useState } from 'react';
import { useTranslation } from 'react-i18next';
import api from '../../lib/api';
import EffortPrompt from '../../components/EffortPrompt';
import LanguageSwitcher from '../../components/LanguageSwitcher';

function LetterFeedback({ guess, target, highlightIndices = [] }: { guess: string; target: string; highlightIndices?: number[] }) {
  const max = Math.max(guess.length, target.length);
  const cells = [] as JSX.Element[];
  for (let i = 0; i < max; i++) {
    const ok = guess[i] === target[i];
    const hl = highlightIndices.includes(i);
    cells.push(
      <span key={i} className={`inline-block w-6 h-8 mx-0.5 text-center align-middle border rounded ${ok? 'bg-green-200 border-green-400':'bg-white border-gray-300'} ${hl ? 'text-red-600 border-red-400' : ''}`}>
        {guess[i]||''}
      </span>
    );
  }
  return <span className="inline-flex flex-wrap align-middle">{cells}</span>;
}

function escapeRegExp(s: string) { return s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); }

function posFlags(guess: string, target: string): boolean[] {
  const len = Math.max(guess.length, target.length);
  const arr: boolean[] = [];
  for (let i = 0; i < len; i++) arr.push(guess[i] === target[i]);
  return arr;
}

function CombinedInput({
  bkey,
  value,
  onChange,
  target,
  submitted,
  feedback,
  onFocus,
  onKeyDown,
  inputRef
}: {
  bkey: string;
  value: string;
  onChange: (v: string) => void;
  target: string;
  submitted: boolean;
  feedback?: boolean[];
  onFocus?: () => void;
  onKeyDown?: (e: React.KeyboardEvent<HTMLInputElement>) => void;
  inputRef?: (el: HTMLInputElement | null) => void;
}) {
  const flags = submitted ? (feedback && feedback.length ? feedback : posFlags(value, target)) : [];
  const placeholderLen = Math.max(target.length, 4);
  const display = (value || '').padEnd(placeholderLen, ' ');
  return (
    <span className="relative inline-block align-baseline">
      <span className={`inline-flex items-center font-mono px-1 py-0.5 border-b-2 ${submitted ? (flags.every(Boolean) ? 'border-green-500 bg-green-50' : 'border-red-500 bg-red-50') : 'border-gray-400'} `}>
        {Array.from(display).map((ch, i) => {
          const isOk = flags.length ? !!flags[i] : undefined;
          const cls = isOk === undefined
            ? 'text-gray-800'
            : (isOk ? 'text-green-700' : 'text-red-700 underline decoration-red-500 decoration-2 underline-offset-2');
          return (
            <span key={i} className={`inline-block whitespace-pre text-base leading-6 ${cls}`}>{ch}</span>
          );
        })}
      </span>
      <input
        className="absolute inset-0 w-full h-full opacity-0 cursor-text"
        value={value}
        onChange={(e) => onChange(e.target.value)}
        onFocus={onFocus}
        onKeyDown={onKeyDown}
        ref={inputRef}
        aria-label={`Blank ${bkey}`}
      />
    </span>
  );
}

export default function GapFill() {
  const { t, i18n } = useTranslation();
  const sessionId = sessionStorage.getItem('sessionId')!;
  const templateId = sessionStorage.getItem('templateId')!;
  const condition = sessionStorage.getItem('condition') as 'self-generate'|'system-provided';
  const targetWords = JSON.parse(sessionStorage.getItem('targetWords') || '[]') as string[];
  const storyText = sessionStorage.getItem('storyText') || '';
  const sentences = JSON.parse(sessionStorage.getItem('sentences') || '[]') as string[];
  const gapPlan = JSON.parse(sessionStorage.getItem('gapPlan') || '[]') as { key: string; kind: 'target'|'distractor'; word?: string; sentenceIndex: number }[];
  const usePlan = false; // preserve paragraphs
  const consent = sessionStorage.getItem(`consent:${sessionStorage.getItem('sessionId') || ''}`) || '';
  if (consent !== 'yes') {
    window.location.assign('/student/consent');
    return null;
  }

  const audioRef = useRef<HTMLAudioElement>(null);
  const [showEndEffort, setShowEndEffort] = useState(false);
  const [activeBlank, setActiveBlank] = useState<string | null>(null);
  const [hintOpen, setHintOpen] = useState(false);

  // Per-blank state keyed by `${wordIndex}_${occurrence}`
  const [answers, setAnswers] = useState<Record<string, string>>({});
  const [feedbackMap, setFeedbackMap] = useState<Record<string, boolean[]>>({});
  const [hintText, setHintText] = useState<Record<string, string>>({});
  const [hintHistory, setHintHistory] = useState<Record<string, { text: string; stage?: string; ts: number }[]>>({});
  const [hintHL, setHintHL] = useState<Record<string, number[]>>({});
  const [attempts, setAttempts] = useState<Record<string, number>>({});
  const [firstAttemptAt, setFirstAttemptAt] = useState<Record<string, number>>({});
  const [revealed, setRevealed] = useState<Record<string, boolean>>({});
  const [submitted, setSubmitted] = useState<Record<string, boolean>>({});
  const [lastIncorrect, setLastIncorrect] = useState<Record<string, boolean>>({});
  const [showTutorial, setShowTutorial] = useState<boolean>(() => !localStorage.getItem('tutorialSeen'));
  const [tIndex, setTIndex] = useState(0);
  const slides = [
    t('gapFill.tutorial.1'),
    t('gapFill.tutorial.2'),
    t('gapFill.tutorial.3'),
    t('gapFill.tutorial.4'),
  ];

  // persist answers across refresh
  const storageKey = `spelllearn.answers.${sessionId}.${templateId}`;
  useEffect(() => {
    try { const saved = localStorage.getItem(storageKey); if (saved) setAnswers(JSON.parse(saved)); } catch {}
  }, []);
  useEffect(() => { try { localStorage.setItem(storageKey, JSON.stringify(answers)); } catch {} }, [answers]);

  // Build a gapped story by sentences using gapPlan, or fallback to local gapping
  const fallbackGapped = useMemo(() => {
    if (usePlan) return '';
    let text = storyText;
    targetWords.forEach((w, wi) => {
      let occ = 0;
      const re = new RegExp(`\\b${escapeRegExp(w)}\\b`, 'gi');
      text = text.replace(re, (m) => {
        if (occ < 1) { const key = `${wi}_${occ}`; occ++; return `{{BLANK_${key}}}`; }
        return m;
      });
    });
    return text;
  }, [usePlan, storyText, targetWords]);

  const allBlankKeys = useMemo(() => {
    
    const keys: string[] = [];
    const token = /\{\{BLANK_(\d+)_(\d+)\}\}/g;
    for (const match of fallbackGapped.matchAll(token)) keys.push(`${match[1]}_${match[2]}`);
    return keys;
  }, [usePlan, gapPlan, fallbackGapped]);

  // Simple normalized Levenshtein for progress
  function normLev(a: string, b: string): number {
    const m = a.length, n = b.length;
    const dp = Array.from({ length: m + 1 }, () => Array(n + 1).fill(0));
    for (let i = 0; i <= m; i++) dp[i][0] = i;
    for (let j = 0; j <= n; j++) dp[0][j] = j;
    for (let i = 1; i <= m; i++) {
      for (let j = 1; j <= n; j++) {
        if (a[i - 1] === b[j - 1]) dp[i][j] = dp[i - 1][j - 1];
        else dp[i][j] = Math.min(dp[i - 1][j - 1] + 1, dp[i - 1][j] + 1, dp[i][j - 1] + 1);
      }
    }
    const dist = dp[m][n];
    const maxLen = Math.max(m, n) || 1;
    let score = 1 - dist / maxLen;
    if (score < 0) score = 0; if (score > 1) score = 1;
    return score;
  }

  // Map of input refs to jump/scroll
  const inputRefs = useRef<Record<string, HTMLInputElement | null>>({});
  function setRef(key: string) {
    return (el: HTMLInputElement | null) => { inputRefs.current[key] = el; };
  }

  function renderGapped() {
    if (!usePlan) {
      const token = /\{\{BLANK_(\d+)_(\d+)\}\}/g;
      const parts: JSX.Element[] = [];
        const paras = fallbackGapped.split(/\r?\n\r?\n+/);
      paras.forEach((para, pi) => {
        const elements: JSX.Element[] = [];
        let lastIndex = 0;
        for (const match of para.matchAll(token)) {
          const mIndex = match.index || 0;
          const before = para.slice(lastIndex, mIndex);
          if (before) elements.push(<span key={`t-${pi}-${lastIndex}`}>{before}</span>);
          const wi = parseInt(match[1], 10);
          const oi = parseInt(match[2], 10);
          const bkey = `${wi}_${oi}`;
          const value = answers[bkey] || '';
          elements.push(
            <span key={`b-${pi}-${bkey}`} className="relative inline-block align-baseline">
              <CombinedInput
                bkey={bkey}
                value={value}
                onChange={(v)=>setAnswers(a=>({ ...a, [bkey]: v }))}
                target={targetWords[wi]}
                submitted={!!submitted[bkey]}
                feedback={feedbackMap[bkey]}
                onFocus={() => setActiveBlank(bkey)}
                onKeyDown={(e)=>{ if(e.key==='Enter'){ e.preventDefault(); handleEnter(bkey);} if((e.ctrlKey||e.metaKey)&& e.key.toLowerCase()==='h'){ e.preventDefault(); setHintOpen(true); askHint(bkey);} }}
                inputRef={setRef(bkey)}
              />
                {activeBlank===bkey && (
                <div className="absolute left-0 top-full mt-1 bg-white border rounded shadow p-1 flex gap-1 z-10">
              {condition === 'self-generate' && (<></>)}
                  {condition === 'system-provided' && (<button type="button" className="text-xs px-2 py-0.5 border rounded" onClick={() => submitAttempt(bkey)} disabled={!value.trim()}>Confirm</button>)}
                </div>
                )}
                {lastIncorrect[bkey] && (
                  <button className="ml-2 text-xs px-2 py-0.5 border rounded bg-amber-50 border-amber-300 text-amber-800" onClick={() => { setHintOpen(true); setActiveBlank(bkey); askHint(bkey); }}>
                    {t('common.hint')}?
                  </button>
                )}
            </span>
          );
          // Reduced visual noise: remove per-letter feedback boxes
          lastIndex = mIndex + match[0].length;
        }
        const rest = para.slice(lastIndex);
        if (rest) elements.push(<span key={`t-end-${pi}`}>{rest}</span>);
          parts.push(<p key={`p-${pi}`} className="mb-3 leading-relaxed">{elements}</p>);
      });
      return parts;
    }
    // Plan-based rendering
    return sentences.map((sentence, si) => {
      const elements: JSX.Element[] = [];
      let text = sentence;
      const inThis = gapPlan.filter(g => g.sentenceIndex === si && g.kind === 'target');
      inThis.forEach((g) => {
        const [wiStr] = g.key.split('_'); const wi = parseInt(wiStr, 10);
        const re = new RegExp(`\\b${escapeRegExp(targetWords[wi] || '')}\\b`, 'i');
        text = text.replace(re, `{{BLANK_${g.key}}}`);
      });
      const token = /\{\{BLANK_(\d+)_(\d+)\}\}/g;
      let lastIndex = 0; let idx = 0;
      for (const match of text.matchAll(token)) {
        const mIndex = match.index || 0;
        const before = text.slice(lastIndex, mIndex);
        if (before) elements.push(<span key={`t-${si}-${lastIndex}`}>{before}</span>);
        const wi = parseInt(match[1], 10);
        const oi = parseInt(match[2], 10);
        const bkey = `${wi}_${oi}`;
        const value = answers[bkey] || '';
        elements.push(
          <span key={`b-${si}-${idx++}`} className="relative inline-block align-baseline">
            <CombinedInput
              bkey={bkey}
              value={value}
              onChange={(v)=>setAnswers(a=>({ ...a, [bkey]: v }))}
              target={targetWords[wi]}
              submitted={!!submitted[bkey]}
              feedback={feedbackMap[bkey]}
              onFocus={() => setActiveBlank(bkey)}
              onKeyDown={(e)=>{ if(e.key==='Enter'){ e.preventDefault(); handleEnter(bkey);} if((e.ctrlKey||e.metaKey)&& e.key.toLowerCase()==='h'){ e.preventDefault(); setHintOpen(true); askHint(bkey);} }}
              inputRef={setRef(bkey)}
            />
            {activeBlank===bkey && (
            <div className="absolute left-0 top-full mt-1 bg-white border rounded shadow p-1 flex gap-1 z-10">
              {condition === 'self-generate' && (<></>)}
              {condition === 'system-provided' && (<button type="button" className="text-xs px-2 py-0.5 border rounded" onClick={() => submitAttempt(bkey)} disabled={!value.trim()}>{t('common.confirm')}</button>)}
            </div>
            )}
            {lastIncorrect[bkey] && (
              <button className="ml-2 text-xs px-2 py-0.5 border rounded bg-amber-50 border-amber-300 text-amber-800" onClick={() => { setHintOpen(true); setActiveBlank(bkey); askHint(bkey); }}>
                {t('common.hint')}?
              </button>
            )}
          </span>
        );
        // Reduced visual noise: remove per-letter feedback boxes
        lastIndex = mIndex + match[0].length;
      }
      const rest = text.slice(lastIndex);
      if (rest) elements.push(<span key={`t-end-${si}`}>{rest}</span>);
      return <span key={`p-${si}`} className="leading-relaxed">{elements} </span>;
    });
  }

async function submitAttempt(bkey: string) {
  if (!(answers[bkey] || '').trim()) return;
  const [wiStr] = bkey.split('_'); const wi = parseInt(wiStr, 10);
  const target = targetWords[wi]; const text = answers[bkey] || '';
  const { data } = await api.post('/api/attempt', { sessionId, storyTemplateId: templateId, taskType: 'gap-fill', targetWord: target, text, condition });
  setAttempts(a => ({ ...a, [bkey]: (a[bkey]||0) + 1 }));
  setFirstAttemptAt(t => ({ ...t, [bkey]: t[bkey] || Date.now() }));
  if (condition === 'self-generate') setFeedbackMap(f => ({ ...f, [bkey]: data.correctnessByPosition || [] }));
  else setHintText(h => ({ ...h, [bkey]: `${data.correctSpelling} - ${data.definition}` }));
  // mark as submitted for progress tracking after submit
  setSubmitted(s => ({ ...s, [bkey]: true }));
  // auto-pause audio if incorrect; jump to next if correct
  try {
    const val = text.trim().toLowerCase();
    const correct = (targetWords[wi]||'').toLowerCase();
    const ok = val.length>0 && (val===correct || normLev(val, correct)>=0.9);
    if (!ok) {
      audioRef.current?.pause();
      setHintOpen(true);
      setActiveBlank(bkey);
      setLastIncorrect(s => ({ ...s, [bkey]: true }));
    }
    if (ok) {
      setLastIncorrect(s => ({ ...s, [bkey]: false }));
      // jump to next incomplete blank
      let next: string | null = null;
      const currIdx = allBlankKeys.indexOf(bkey);
      const order = currIdx >= 0 ? [...allBlankKeys.slice(currIdx + 1), ...allBlankKeys.slice(0, currIdx)] : allBlankKeys;
      for (const key of order) {
        const [wStr] = key.split('_'); const wi2 = parseInt(wStr, 10);
        const val2 = (answers[key]||'').trim().toLowerCase();
        const correct2 = (targetWords[wi2]||'').toLowerCase();
        const done = val2.length>0 && (val2===correct2 || normLev(val2, correct2) >= 0.9);
        if (!done) { next = key; break; }
      }
      if (next) {
        const el = inputRefs.current[next];
        if (el) { el.scrollIntoView({ behavior: 'smooth', block: 'center' }); el.focus(); }
        setActiveBlank(next);
      }
    }
  } catch {}
}

  async function askHint(bkey: string) {
    const [wiStr] = bkey.split('_'); const wi = parseInt(wiStr, 10);
    const target = targetWords[wi];
    const { data } = await api.post('/api/hint', { sessionId, targetWord: target, locale: i18n.language || 'en' });
    setHintText(h => ({ ...h, [bkey]: data.hint }));
    setHintHL(h => ({ ...h, [bkey]: data.ui?.indices || [] }));
    setActiveBlank(bkey);
    setHintHistory((prev) => {
      const list = prev[bkey] || [];
      return { ...prev, [bkey]: [...list, { text: data.hint, stage: data.stage, ts: Date.now() }] };
    });
  }

  async function doReveal(bkey: string) {
    const [wiStr] = bkey.split('_'); const wi = parseInt(wiStr, 10);
    const target = targetWords[wi];
    await api.post('/api/reveal', { sessionId, storyTemplateId: templateId, targetWord: target });
    setRevealed(r => ({ ...r, [bkey]: true }));
  }

  function skip(deltaSec: number) { const a = audioRef.current; if (!a) return; a.currentTime = Math.max(0, a.currentTime + deltaSec); }

  // No sentence gating; use full story audio only for simpler UX

  const audioUrl = sessionStorage.getItem('audioUrl') || '';
  const difficulty = (sessionStorage.getItem('difficulty') || 'A1') as 'A1'|'A2'|'B1'|'B2'|'C1'|'C2';
  const [playing, setPlaying] = useState(false);
  useEffect(() => {
    const a = audioRef.current;
    if (!a) return;
    const rateMap: Record<string, number> = { A1: 0.85, A2: 0.9, B1: 1.0, B2: 1.05, C1: 1.1, C2: 1.15 };
    a.playbackRate = rateMap[difficulty] || 1.0;
  }, [audioRef.current, difficulty]);
  useEffect(() => {
    const a = audioRef.current; if (!a) return;
    const onPlay = () => setPlaying(true);
    const onPause = () => setPlaying(false);
    a.addEventListener('play', onPlay);
    a.addEventListener('pause', onPause);
    return () => { a.removeEventListener('play', onPlay); a.removeEventListener('pause', onPause); };
  }, [audioRef.current]);
  function togglePlay() { const a = audioRef.current; if (!a) return; if (a.paused) a.play(); else a.pause(); }
  return (
    <div className="focus-wide">
      <div className="flex justify-end mb-2"><LanguageSwitcher /></div>
        <div className="sticky-audio p-3 flex items-center gap-3">
          <audio ref={audioRef} className="hidden" src={audioUrl} />
          <button className="px-3 py-1.5 border rounded" onClick={()=>skip(-3)} aria-label="Rewind 3 seconds">-3s</button>
          <button className="px-3 py-1.5 border rounded bg-gray-900 text-white" onClick={togglePlay} aria-label={playing? 'Pause':'Play'}>
            {playing ? 'Pause' : 'Play'}
          </button>
          <button className="px-3 py-1.5 border rounded" onClick={()=>skip(3)} aria-label="Forward 3 seconds">+3s</button>
        </div>
        <div className="grid md:grid-cols-[1fr_320px] gap-4">
          <div className="w-full text-lg leading-7 whitespace-pre-wrap">{renderGapped()}</div>
          <div>
            <HintsPanel activeKey={activeBlank} hintText={hintText} hintHistory={hintHistory} />
            <div className="mt-3">
              <ProgressPanel targetWords={targetWords} blanks={allBlankKeys} answers={answers} scoreFn={normLev} submitted={submitted} />
            </div>
          </div>
        </div>
      <div className="mt-4 flex justify-end">
        <button className="bg-blue-600 text-white px-4 py-2 rounded" onClick={() => setShowEndEffort(true)}>{t('gapFill.finish')}</button>
      </div>
      <EffortPrompt open={showEndEffort} onClose={() => { setShowEndEffort(false); window.location.assign('/student/recall-immediate'); }} sessionId={sessionId} taskType="gap-fill" position="end" />
      {showTutorial && (
        <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50">
          <div className="bg-white p-5 rounded shadow max-w-lg w-full" onClick={e=>e.stopPropagation()}>
            <h3 className="font-semibold mb-2">Quick Tutorial</h3>
            <p className="text-sm text-gray-700 min-h-[60px]">{slides[tIndex]}</p>
            <div className="mt-4 flex justify-between">
              <button className="px-3 py-1 border rounded" onClick={()=> setTIndex(i=> Math.max(0, i-1))} disabled={tIndex===0}>Back</button>
              {tIndex < slides.length - 1 ? (
                <button className="px-3 py-1 bg-blue-600 text-white rounded" onClick={()=> setTIndex(i=> i+1)}>Next</button>
              ) : (
                <button className="px-3 py-1 bg-green-600 text-white rounded" onClick={()=> { localStorage.setItem('tutorialSeen','yes'); setShowTutorial(false); }}>Start</button>
              )}
            </div>
          </div>
        </div>
      )}
    </div>
  );
}

function ProgressPanel({ blanks, answers, scoreFn, submitted }: { blanks: string[]; answers: Record<string,string>, scoreFn: (a:string,b:string)=>number, submitted: Record<string, boolean> }) {
  const items = blanks.map((key) => {
    const [wiStr, oiStr] = key.split('_');
    const wi = parseInt(wiStr, 10); const oi = parseInt(oiStr, 10);
    const val = (answers[key]||'').trim().toLowerCase();
    const done = submitted[key] && val.length>0;
    return { key, wi, oi, done };
  });
  const doneCount = items.filter(i => i.done).length;
  return (
    <div className="mt-4 p-3 bg-gray-50 border rounded">
      <div className="text-sm font-medium mb-2">Progress: {doneCount} / {items.length}</div>
    </div>
  );
}

function HintsPanel({ activeKey, hintText, hintHistory }: { activeKey: string | null; hintText: Record<string, string>; hintHistory: Record<string, { text: string; stage?: string; ts: number }[]> }) {
  const text = (activeKey && hintText[activeKey]) || '';
  const history = (activeKey && hintHistory[activeKey]) || [];
  return (
    <aside className="p-3 border rounded bg-gray-50 h-fit sticky top-20">
      <div className="font-medium mb-2">Hint</div>
      {text ? <div className="text-sm text-gray-800 mb-2">{text}</div> : <div className="text-sm text-gray-500 mb-2">Focus a blank and request a hint.</div>}
      {history.length > 0 && (
        <div>
          <div className="text-xs text-gray-600 mb-1">History</div>
          <ul className="space-y-1">
            {history.slice(-5).reverse().map((h, i) => (
              <li key={i} className="text-xs text-gray-700">- {h.text} {h.stage ? <span className="text-gray-500">({h.stage})</span> : null}</li>
            ))}
          </ul>
        </div>
      )}
    </aside>
  );
}

  













