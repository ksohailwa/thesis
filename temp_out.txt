import { useEffect, useMemo, useRef, useState } from 'react';
import api from '../../lib/api';
import { toast } from '../../store/toasts';

type StoryPayload = {
  paragraphs?: string[];
  occurrences?: { word: string; paragraphIndex: number; sentenceIndex?: number; charStart?: number; charEnd?: number }[];
};

type Blank = {
  key: string;
  word: string;
  occurrenceIndex: number;
  paragraphIndex: number;
  charStart?: number;
  charEnd?: number;
};

function parseParagraph(
  paragraph: string,
  pIdx: number,
  wordCounts: Record<string, number>,
  occs?: StoryPayload['occurrences']
): { segments: (string | Blank)[]; blanks: Blank[] } {
  const blanks: Blank[] = [];
  // Prefer bold markers
  if (paragraph.includes('**')) {
    const parts = paragraph.split(/(\*\*[^*]+\*\*)/g);
    const segments: (string | Blank)[] = [];
    parts.forEach((part) => {
      const m = part.match(/^\*\*([^*]+)\*\*$/);
      if (m) {
        const word = m[1];
        const idx = (wordCounts[word] || 0) + 1;
        wordCounts[word] = idx;
        const blank: Blank = { key: `${word}-${idx}-${pIdx}-${blanks.length}`, word, occurrenceIndex: idx, paragraphIndex: pIdx };
        blanks.push(blank);
        segments.push(blank);
      } else if (part) {
        segments.push(part);
      }
    });
    return { segments, blanks };
  }

  // If occurrences provided, use char positions
  const paraOcc = (occs || []).filter((o) => o.paragraphIndex === pIdx);
  paraOcc.sort((a, b) => (b.charStart ?? 0) - (a.charStart ?? 0));
  let working = paragraph;
  const segments: (string | Blank)[] = [working];
  paraOcc.forEach((o) => {
    const idx = (wordCounts[o.word] || 0) + 1;
    wordCounts[o.word] = idx;
    const blank: Blank = {
      key: `${o.word}-${idx}-${pIdx}-${blanks.length}`,
      word: o.word,
      occurrenceIndex: idx,
      paragraphIndex: pIdx,
      charStart: o.charStart,
      charEnd: o.charEnd,
    };
    blanks.push(blank);
    for (let i = 0; i < segments.length; i++) {
      const seg = segments[i];
      if (typeof seg !== 'string') continue;
      const pos = seg.toLowerCase().lastIndexOf(o.word.toLowerCase());
      if (pos >= 0) {
        const before = seg.slice(0, pos);
        const after = seg.slice(pos + o.word.length);
        segments.splice(i, 1, before, blank, after);
        break;
      }
    }
  });
  return { segments, blanks };
}

export default function StudentTest() {
  const assignmentId = sessionStorage.getItem('assignmentId') || '';
  const experimentId = sessionStorage.getItem('exp.experimentId') || '';
  const condition = sessionStorage.getItem('exp.condition') || 'with_hints';
  const story1 = JSON.parse(sessionStorage.getItem('exp.story1') || '{}') as StoryPayload;
  const story2 = JSON.parse(sessionStorage.getItem('exp.story2') || '{}') as StoryPayload;
  const tts1 = sessionStorage.getItem('exp.tts1') || '';
  const tts2 = sessionStorage.getItem('exp.tts2') || '';
  const cues1 = JSON.parse(sessionStorage.getItem('exp.cues1') || '[]') as any[];
  const cues2 = JSON.parse(sessionStorage.getItem('exp.cues2') || '[]') as any[];

  const [storyIndex, setStoryIndex] = useState(0);
  const [values, setValues] = useState<Record<string, string>>({});
  const [correct, setCorrect] = useState<Record<string, boolean>>({});
  const [feedback, setFeedback] = useState<Record<string, boolean[]>>({});
  const [hint, setHint] = useState<string | null>(null);
  const [hintForKey, setHintForKey] = useState<string | null>(null);
  const [hintHistory, setHintHistory] = useState<{ key: string; text: string }[]>([]);
  const [showHelp, setShowHelp] = useState(false);
  const audioRef = useRef<HTMLAudioElement>(null);
  const base = import.meta.env.VITE_API_BASE_URL || '';

  const stories = useMemo(() => [story1, story2], [story1, story2]);
  const cues = storyIndex === 0 ? cues1 : cues2;
  const tts = storyIndex === 0 ? tts1 : tts2;
  const audioSrc = useMemo(() => {
    if (tts) return tts.startsWith('http') ? tts : `${base}${tts}`;
    if (experimentId) {
      const label = storyIndex === 0 ? 'H' : 'N';
      return `${base}/static/audio/${experimentId}/${label}.mp3`;
    }
    return undefined;
  }, [tts, base, experimentId, storyIndex]);

  const parsed = useMemo(() => {
    const story = stories[storyIndex] || {};
    const res: { paragraphs: { segments: (string | Blank)[]; blanks: Blank[] }[]; blanks: Blank[] } = { paragraphs: [], blanks: [] };
    (story.paragraphs || []).forEach((p, pIdx) => {
      const wordCounts: Record<string, number> = {};
      const parsedPara = parseParagraph(p, pIdx, wordCounts, story.occurrences);
      res.paragraphs.push(parsedPara);
      res.blanks.push(...parsedPara.blanks);
    });
    return res;
  }, [stories, storyIndex]);

  const totalBlanks = parsed.blanks.length;
  const solved = Object.values(correct).filter(Boolean).length;
  const progressPct = totalBlanks ? Math.min(100, Math.round((solved / totalBlanks) * 100)) : 0;

  // Auto-pause near end of current cue
  useEffect(() => {
    if (!audioRef.current) return;
    const handler = () => {
      if (!audioRef.current) return;
      const t = audioRef.current.currentTime;
      const next = cues.find((c) => t <= c.endSec + 0.1);
      if (next && t >= next.endSec && solved < totalBlanks) {
        audioRef.current.pause();
      }
    };
    audioRef.current.addEventListener('timeupdate', handler);
    return () => audioRef.current?.removeEventListener('timeupdate', handler);
  }, [cues, solved, totalBlanks]);

  const handleCheck = async (blank: Blank) => {
    const text = (values[blank.key] || '').trim();
    if (!text) return;
    try {
      const { data } = await api.post('/api/student/test-attempt', {
        assignmentId,
        storyLabel: storyIndex === 0 ? 'story1' : 'story2',
        word: blank.word,
        occurrenceIndex: blank.occurrenceIndex,
        text,
      });
      setFeedback((f) => ({ ...f, [blank.key]: data.correctnessByPosition || [] }));
      if (data.isCorrect) {
        setCorrect((c) => ({ ...c, [blank.key]: true }));
        setHint(null);
        setHintForKey(null);
        toast.success('Correct!');
        audioRef.current?.play().catch(() => {});
      } else {
        toast.error('Try again');
        audioRef.current?.pause();
        if (data.canHint) {
          setHint('Click Hint for help');
          setHintForKey(blank.key);
        }
      }
    } catch {
      toast.error('Check failed');
    }
  };

  const handleHint = async (blank: Blank) => {
    try {
      const { data } = await api.post('/api/student/test-hint', {
        targetWord: blank.word,
        latestAttempt: values[blank.key] || '',
        occurrenceIndex: blank.occurrenceIndex,
        uiLanguage: 'en',
      });
      setHint(data?.hint || '');
      setHintForKey(blank.key);
      if (data?.hint) {
        setHintHistory((h) => [...h, { key: blank.key, text: data.hint }]);
      }
    } catch {
      toast.error('Hint failed');
    }
  };

  const renderBlank = (b: Blank) => {
    const val = values[b.key] || '';
    const ok = !!correct[b.key];
    const fb = feedback[b.key] || [];
    return (
      <span key={b.key} className="inline-flex items-center gap-2 align-baseline">
        <input
          className={`px-3 py-2 border-2 rounded-lg text-lg font-semibold text-center ${
            ok ? 'border-green-500 bg-green-50' : 'border-gray-300'
          }`}
          value={val}
          onChange={(e) => setValues((v) => ({ ...v, [b.key]: e.target.value }))}
          onKeyDown={(e) => {
            if (e.key === 'Enter') {
              handleCheck(b);
            }
          }}
          disabled={ok}
          style={{ width: `${Math.max(6, b.word.length + 2)}ch` }}
        />
        {fb.length > 0 && (
          <span className="font-mono text-sm">
            {fb.map((f, i) => (
              <span key={i} className={f ? 'text-green-600' : 'text-red-600'}>
                {(val[i] || '').toUpperCase() || '_'}
              </span>
            ))}
          </span>
        )}
        {!ok && (
          <button className="text-sm px-2 py-1 border rounded-lg bg-white hover:shadow" onClick={() => handleCheck(b)}>
            Check
          </button>
        )}
        {!ok && condition === 'with_hints' && (
          <button className="text-sm px-2 py-1 border rounded-lg bg-white hover:shadow" onClick={() => handleHint(b)}>
            Hint
          </button>
        )}
        {ok && <span className="text-green-600 text-sm">✓</span>}
      </span>
    );
  };

  return (
    <div className="min-h-screen bg-gradient-to-br from-purple-50 via-white to-pink-50 text-gray-900">
      {/* Sticky header with progress and audio */}
      <div className="sticky top-16 z-30 bg-white/90 backdrop-blur border-b shadow-sm">
        <div className="w-full max-w-6xl mx-auto px-6 py-3">
          <div className="flex items-center justify-between mb-2">
            <div>
              <div className="text-sm font-semibold text-gray-700">Story {storyIndex + 1} of 2</div>
              <div className="text-xs text-gray-500">Progress: {solved}/{totalBlanks}</div>
            </div>
            <button className="px-3 py-1.5 border rounded-lg bg-white hover:shadow transition" onClick={() => setShowHelp(true)}>
              Help
            </button>
          </div>
          <div className="w-full bg-gray-200 rounded-full h-2 overflow-hidden mb-2">
            <div className="h-full bg-gradient-to-r from-purple-500 to-pink-500 transition-all duration-500 rounded-full" style={{ width: `${progressPct}%` }} />
          </div>
          <div className="bg-white border border-gray-200 rounded-lg shadow-sm p-2 flex flex-wrap items-center gap-3">
            <audio ref={audioRef} controls className="flex-1 min-w-[240px]" src={audioSrc} />
            <div className="flex items-center gap-2">
              <button
                className="px-2.5 py-1 border rounded-lg bg-white hover:shadow transition"
                onClick={() => {
                  if (audioRef.current) audioRef.current.currentTime = Math.max(0, audioRef.current.currentTime - 3);
                }}
              >
                ⏪ -3s
              </button>
              <button className="px-2.5 py-1 border rounded-lg bg-white hover:shadow transition" onClick={() => audioRef.current?.play()}>
                ▶️
              </button>
              <button className="px-2.5 py-1 border rounded-lg bg-white hover:shadow transition" onClick={() => audioRef.current?.pause()}>
                ⏸️
              </button>
              <button
                className="px-2.5 py-1 border rounded-lg bg-white hover:shadow transition"
                onClick={() => {
                  if (audioRef.current) audioRef.current.currentTime = audioRef.current.currentTime + 3;
                }}
              >
                ⏩ +3s
              </button>
            </div>
          </div>
        </div>
      </div>

      <div className="w-full px-4 py-10">
        <div className="space-y-8 max-w-4xl">
          {parsed.paragraphs.map((para, idx) => (
            <p key={idx} className="text-lg leading-relaxed">
              {para.segments.map((seg, i) =>
                typeof seg === 'string' ? <span key={i}>{seg}</span> : <span key={seg.key}>{renderBlank(seg)}</span>
              )}
            </p>
          ))}
          {storyIndex === 0 && solved === totalBlanks && (
            <button
              className="mt-6 px-6 py-3 bg-purple-600 text-white rounded-xl font-semibold shadow hover:shadow-lg"
              onClick={() => {
                setStoryIndex(1);
                setValues({});
                setCorrect({});
                setFeedback({});
                setHint(null);
                setHintForKey(null);
                setHintHistory([]);
              }}
            >
              Continue to Story 2
            </button>
          )}
          {storyIndex === 1 && solved === totalBlanks && (
            <div className="mt-6 p-6 border rounded-2xl bg-green-50 text-green-800 font-semibold shadow-sm">
              All done! Great work.
            </div>
          )}
        </div>
      </div>

      {showHelp && (
        <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50 p-4" onClick={() => setShowHelp(false)}>
          <div className="bg-white rounded-2xl shadow-2xl max-w-lg w-full p-6" onClick={(e) => e.stopPropagation()}>
            <h3 className="text-xl font-bold mb-3">How to complete the test</h3>
            <ul className="list-disc pl-5 space-y-2 text-sm text-gray-700">
              <li>Play the audio and follow along with the story.</li>
              <li>Type the target word into each blank; press Enter or click Check.</li>
              <li>Green letters = correct; red = needs fixing.</li>
              <li>If allowed, use the Hint button after a wrong attempt.</li>
              <li>Finish all blanks in Story 1, then continue to Story 2.</li>
            </ul>
            <div className="text-right mt-4">
              <button className="px-4 py-2 border rounded-lg" onClick={() => setShowHelp(false)}>
                Close
              </button>
            </div>
          </div>
        </div>
      )}

      {/* Floating hint panel (chat-like) */}
      <div className="fixed right-6 bottom-6 w-80 max-h-[60vh] hidden lg:block z-40 pointer-events-none">
        <div className="p-4 border rounded-2xl bg-white shadow-2xl pointer-events-auto h-full flex flex-col">
          <div className="font-bold mb-2">Hints</div>
          <div className="text-xs text-gray-500 mb-2">
            {hintHistory.length ? 'Latest hints' : 'Request a hint to see it here.'}
          </div>
          <div className="flex-1 overflow-y-auto space-y-2">
            {hintHistory.length === 0 && <div className="text-sm text-gray-600">No hints yet.</div>}
            {hintHistory.map((h, idx) => (
              <div key={`${h.key}-${idx}`} className="p-2 rounded-lg bg-amber-50 border border-amber-200 text-amber-800 text-sm">
                {h.text}
              </div>
            ))}
          </div>
        </div>
      </div>

      {!showHelp && (
        <button
          className="fixed bottom-6 right-6 w-12 h-12 rounded-full shadow-lg bg-purple-600 text-white text-lg font-bold hover:shadow-xl"
          onClick={() => setShowHelp(true)}
          aria-label="Help"
        >
          ?
        </button>
      )}
    </div>
  );
}

